////
Copyright (c) 2023 Industrial Digital Twin Association

This work is licensed under a [Creative Commons Attribution 4.0 International License](
https://creativecommons.org/licenses/by/4.0/). 

SPDX-License-Identifier: CC-BY-4.0

////

include::../includes/special-parameters.adoc[]

include::../includes/constraints.adoc[]

= HTTP/REST API

== General

This clause describes the technology mapping to HTTP/REST APIs.

The OpenAPI specification of the HTTP/REST APIs can be found at SwaggerHub.

To clearly separate the different parts of the AAS model, the model has been split into several HTTP/REST APIs.
Combinations then form service specifications and profiles, each materialized as an individual OpenAPI document.

The schema for the metamodel of Part 1 is available at: +
https://app.swaggerhub.com/domains/Plattform_i40/Part1-MetaModel-Schemas/V3.1.0#[https://app.swaggerhub.com/domains/Plattform_i40/Part1-MetaModel-Schemas/V3.1.0#] +
This schema includes general objects, which are used in the further defined APIs.

Additional objects are needed for Part 2, e.g., the Descriptors for the Registry.
The related schema of Part 2 objects is available at: +
https://app.swaggerhub.com/domains/Plattform_i40/Part2-API-Schemas/V3.1.0#[https://app.swaggerhub.com/domains/Plattform_i40/Part2-API-Schemas/V3.1.0#] +
This schema includes general objects, which are used in the further defined APIs.

The AAS Service Specification including the AAS API, the Submodel API, the Serialization API, and the Self-Description API is available at: +
https://app.swaggerhub.com/apis/Plattform_i40/AssetAdministrationShellServiceSpecification/V3.1.0_SSP-001#[https://app.swaggerhub.com/apis/Plattform_i40/AssetAdministrationShellServiceSpecification/V3.1.0_SSP-001#] +

The Submodel Service Specification including the Submodel API, the Serialization API, and the Self-Description API is available at: +
https://app.swaggerhub.com/apis/Plattform_i40/SubmodelServiceSpecification/V3.1.0_SSP-001#[https://app.swaggerhub.com/apis/Plattform_i40/SubmodelServiceSpecification/V3.1.0_SSP-001#] +

The AAS Repository Service Specification including the AAS Repository API, the AAS API, the Submodel API, the Submodel Repository API, the Serialization API, and the Self-Description API is available at: https://app.swaggerhub.com/apis/Plattform_i40/AssetAdministrationShellRepositoryServiceSpecification/V3.1.0_SSP-001#[https://app.swaggerhub.com/apis/Plattform_i40/AssetAdministrationShellRepositoryServiceSpecification/V3.1.0_SSP-001#] +

The Submodel Repository Service Specification including the Submodel Repository API, Submodel API, the Serialization API, and the Self-Description API is available at: https://app.swaggerhub.com/apis/Plattform_i40/SubmodelRepositoryServiceSpecification/V3.1.0_SSP-001#[https://app.swaggerhub.com/apis/Plattform_i40/SubmodelRepositoryServiceSpecification/V3.1.0_SSP-001#] +

The AAS Registry Service Specification Registry including the AAS Registry API and the Self-Description API is available at: +
https://app.swaggerhub.com/apis/Plattform_i40/AssetAdministrationShellRegistryServiceSpecification/V3.1.0_SSP-001#[https://app.swaggerhub.com/apis/Plattform_i40/AssetAdministrationShellRegistryServiceSpecification/V3.1.0_SSP-001#]

The Submodel Registry Service Specification including the Submodel Registry API and the Self-Description API is available at https://app.swaggerhub.com/apis/Plattform_i40/SubmodelRegistryServiceSpecification/V3.1.0_SSP-001#[https://app.swaggerhub.com/apis/Plattform_i40/SubmodelRegistryServiceSpecification/V3.1.0_SSP-001#]

The Service Specification including the AAS Discovery API and the Self-Description API is available at:
https://app.swaggerhub.com/apis/Plattform_i40/DiscoveryServiceSpecification/V3.1.0_SSP-001#[https://app.swaggerhub.com/apis/Plattform_i40/DiscoveryServiceSpecification/V3.1.0_SSP-001#]

This clause gives an overview of the HTTP/REST API and describes general design decisions.

== Design Decisions

The following design decisions and constraints hold for the HTTP/REST API:

* OpenAPI and SwaggerHub shall be used for specification.
This leads to the constraint that one operation can only provide one type of a resulting payload.
* This document assumes version 1.1 of HTTP.
* An endpoint of the HTTP/REST API shall always use HTTPS (Port 443) with an up-to-date level of encryption.
* The SerializationModifier “content” changes the type the of payload for inputs or results.
To ensure type-safe APIs, this parameter is mapped to the path suffixes “/$value”, “/$metadata”, “/$reference”, and “/$path”. “content=Normal” is mapped to the path without any “/$<content>” suffix.
* Generic SerializationModifiers changing the size of payload for input or result have been mapped to corresponding query parameters, e.g. ”?level=” or “?extent=”.
* Query parameters are also used when the type of a resulting payload is a list of objects and the type remains the same, while the query parameter filters the content of the list, e.g. GetAllSubmodels with optional query parameters “?semanticId=” or “?idShort=”.
* Complete objects are provided as requested payloads, e.g. a complete submodel.
This corresponds to the generic SerializationModifier content=”Normal”.
Reduced objects can be requested by the path suffix “/$<content>”.
// Previously pointing to Clause 12.5
See xref:bibliography.adoc#bib1[[1]] for further details.
Exceptions to this rule are API Operations requiring pagination and error cases.
* By default, blobs are not part of the payload.
Using ?extent=WithBLOBValue includes blobs for submodel elements of kind BLOB.
* Submodels define a hierarchical structure.
Certain operations use an idShortPath to access deeper parts in the hierarchy.
To easily support this in the REST API, “.” or “[index]” is used as a delimiter in the idShortPaths.
Please see <<api-versioning>>.
Since an idShortPath could include square brackets like “[index]”, the idShortPath must be URL-encoded.
* Identifiers of Identifiables are base64url-encoded to be passed to the HTTP/REST API (see https://www.base64url.com/).
These may be identifiers for Asset Administration Shells, Submodels, or Concept Descriptions. +
Identifiers may also be passed as base64url-encoded query parameters, e.g. for semanticId or assetId.
Such query parameters are typically used when a list of objects may be retrieved in the resulting payload.
A list of base64url-encoded ids is simply passed as comma-separated query parameters.
* Please note that base64url-encoding differs slightly from base64-encoding and has been specifically defined for passing URLs.
In particular, base64url-encoded values shall contain or end with the `=` character (so-called 'padding') to keep them URL-safe.
An appropriate base64url implementation needs to be used for encoding/decoding.
See RFC 4648 for further details.

====
Note: Encoding JSON objects may lead to different encoded strings, depending e.g. whether control characters (white spaces, line-breaks etc.) are included or not. However, servers must be able to deal with included control characters and operate on the original content.
====

* When base64url or base64-encoding is mentioned in connection with string values (e.g. Identifiers), the UTF-8 decoded byte array representation of that string is used for the base64url or base64-encoding.
* When retrieving AssetAdministrationShells (/shells, /lookup/shells), a query parameter “?assetids=” can be specified.
Such assetId may be a globalAssetId or specificAssetId.
The corresponding key-value-pair is first serialized to JSON and then base64url-encoded.
The resulting encoded string is the value of “?assetids=”.

====
Note: In case more than one globalAssetId or specificAssetId is provided, their order shall not affect the result.
====

* In some operations, references are part of the query parameters e.g. “?semanticId=”.
The corresponding reference is first serialized to JSON and then base64url-encoded.
The resulting encoded string is the value of “?semanticId=”.
* Even though the metamodel of the AAS distinguishes between the attributes “semanticId” and “supplementalSemanticId”, the query parameter “?semanticId” targets both.
* This encoding (serialize to JSON + base64url) is also used for SpecificAssetIds, i.e. for GetAllAssetAdministrationShellIdsByAssetLink (/lookup/shells).
For the example “[\{"name": "globalAssetId","value": "http://example.company/myAsset"},\{"name": "myOwnInternalAssetId","value": "12345ABC"}]”, the resulting base64url-encoded value of the query parameter is +
“?assetIds=W3sibmFtZSI6ICJnbG9iYWxBc3NldElkIiwidmFsdWUiOiAiaHR0cDovL2V4YW1wbGUuY29tcGFueS9teUFzc2V0In0seyJuYW1lIjogIm15T3duSW50ZXJuYWxBc3NldElkIiwidmFsdWUiOiAiMTIzNDVBQkMifV0”. +
If several key-value-pairs are included, all must be part of the key-value-pairs on the server.
* Comparisons of idShort are made case-sensitive in the HTTP/REST API to avoid repeating toupper()/tolower() conversions.

====
Note: this is conformant to the change made in Part 1 V3.0 xref:bibliography.adoc#bib1[[1\]].
====

* GetAll…-API Operations will retrieve a list of objects as the resulting payload, e.g. GetAllSubmodelElements.
* The splitting of big result sets into smaller pieces, commonly referred to as “pagination”, is executed using the cursor query parameter.
Therefore, result objects for GetAll…-API Operations and others requiring pagination return their content inside a Result structure.
See <<pagination>> for further explanations.
* In general, only GET, POST, PUT, PATCH and DELETE are used.
POST is used to create new objects and to invoke operations.
[[superpaths]]
* Some interfaces may be combined in a so-called “superpaths”, e.g. the Asset Administration Shell Repository Interface may be combined with the AAS Interface and the Submodel Interface.
This results in a complete path like “/shells/\{aas-identifier}/submodels/\{submodel-identifier}/*”.
This is especially useful when all data is hosted in the same repository.
Superpaths are defined as part of the service specifications and profiles.
* The attribute AssetAdministrationShell/submodels (array of References) maps to the path segment “/submodel-refs” to distinguish it from the superpath segment “/submodels” (array of Submodels).
* Each interface includes a “/description” operation for self-discovery to provide detailed information about the interface.
A server supporting the HTTP/REST API may also provide a server global “/description” to provide the information about all available profiles on that server.
* The AAS Query Language is serialised as a JSON Object.
* The recursive nature of the reference class (Reference/referredSemanticId points to Reference again) cannot be represented in SwaggerHub due to a bug in the SwaggerUI code. Therefore, the additional class “ReferenceParent" has been added. “ReferenceParent" shall not be used in productive operations and is only a placeholder for “Reference”. When implementing generated code originating from the SwaggerHub schemas, please delete “ReferenceParent” and add its attributes to “Reference”.
* This document does not make any statement about the expected behavior when query parameters with cardinality 1 (e.g. level, extent, etc.) are present more than once in a URL, e.g., "/...?level=deep&level=core". It is up to the implementation how to handle such cases. It is strongly discouraged to make such calls as the result might not be deterministic.

[#api-versioning]
== API Versioning

The versioning scheme for AAS API related services follows semantic versioningfootnote:[http://semver.org]. Very briefly, this defines version numbers as a format following: <MAJOR>.<MINOR>.<PATCH>.

The major version changes in case of breaking or incompatible changes that need to be addressed by clients. Minor versions add (new) functionality in a backwards compatible way and allow clients with lower minor versions to keep their existing functionality. Patch versions only include backwards compatible bug fixes.

AAS API versioning uses the major and minor version as described above. A specific AAS API version uses specific related versions of the metamodel as defined in xref:index.adoc#metamodel-versions[]. AAS API versions with the same major version must remain compatible, i.e. a client written for an older or a newer minor version must still work. This requires corresponding testing of clients and servers.

Additionally, "Release candidates" are variants of the implementation of the denoted major version. For example, "3.1.0RC2" should be interpreted as the second (alternative) release candidate for version 3.1.0.

To provide multiple versions of the APIs to clients, an AAS ecosystem consisting of Registry / Discovery services as well as AAS Repository, Submodel (standalone), or AAS (standalone) services should share a consistent version.
Therefore, a consistent interface description in the form of OpenAPI documents shall be provided with each major version.

Upcoming compatibility constraints regarding newer versions will be elaborated in further iterations of this document and related technical descriptions (OpenAPI specification).

API versioning provides a way to deal with different versions of the same API at the same time. This way, older versions may still be accessible on the same server to provide services to legacy clients without breaking existing functionality. 

There are different solutions regarding API versioning involving URL-based versioning, query parameter-based versioning, as well as HTTP header-oriented solutions using custom or standard headers.

.Example of an AAS endpoint with URL-based versioning
[[aas-api-versioning-url-scheme]]
image::aas-api-versioning-url-scheme.svg[width=481,height=110]

As different solutions also provide different advantages and disadvantages, URL-based versioning is recommended for the AAS API. Among other advantages, implementation complexity on clients as well as servers is rather low and different versions can be easily accessed through browsers without the need for specific development tools or extensions.

Upcoming implementations of AAS related servers may implement the version prefix “api/v<X>/” to provide information of the specific major version regarding AAS Part 2 version, where <X> denotes the implemented major version, e.g. “api/v3/” (see <<aas-api-versioning-url-scheme>>). 
As minor releases of one major version must not contain any breaking changes, the declaration of the minor version can be omitted.

Nevertheless, AAS servers may decide to use different paths depending on their context, see  <<aas-api-versioning-url-scheme2>>. The fragment before the functional endpoint is not necessarily the version information itself, it may also be a tenant ID or any other information the server decides to use. A client shall not assume that the pattern from  <<aas-api-versioning-url-scheme>> is supported by all servers.

.Example of an AAS endpoint with an arbitrary path
[[aas-api-versioning-url-scheme2]]
image::aas-api-versioning-url-scheme2.png[width=481,height=110]

Finally, it is recommended to include an additional "/description” endpoint into each service to further denote information about APIs / servers capabilities.
This endpoint provides further information about the API and its supported profiles.
The “/description” will be extended with additional information in later versions.

====
Note: The profile identifiers provided at the "/description" endpoint (see Clause xref:specification/interfaces-payload.adoc#service-description[]) contain both the major and minor version declaration.
====


== Addressing Resources

The API allows to address each referable element, either by its global identifier or by its idShortPath depending on the object type.

If the referable element is an identifiable, it can only be addressed by the global identifier of the object.
All other referable elements are addressable by the idShortPath.
The idShortPath is a chain of idShorts or SubmodelElementList-indexes, which points to an element within a hierarchy of elements.
The root of the idShortPath is always a submodel and the first element in an idShortPath is always an idShort of a first level SubmodelElement within a Submodel.
Technically, the idShortPath is a string and the idShorts are separated by a dot while the SubmodelElementList-indexes are written in brackets.

.Example Hierarchy of Submodel Elements
[[se-hierarchy]]
image::se-hierarchy.png[image24,width=642,height=367]

The example hierarchy in <<se-hierarchy>> shows a Submodel with a hierarchical structure of SubmodelElements.
The submodel can be addressed by its global identifier “https://admin-shell.io/sampleSM”.
The other elements in the figure do not have a global identifier; they are, however, uniquely identifiable and addressable by the submodel identifier and the idShortPath.
The idShortPath in this example pointing to the Property p1 is “sme1.sme2[0].p1”.
The hierarchy is built on parent-child relations between the elements.
There are four elements which can aggregate SubmodelElements and create deeper hierarchical structures.
The elements are Submodel, SubmodelElementCollection, SubmodelElementList, and Entity.
The fields used to navigate to a deeper level of the hierarchy can be seen in the following table.

.Children of certain objects
[%autowidth,width="100%",options="header",]
|===
|*Element Name* |*Child aggregation field name*
|Submodel |SubmodelElement
|SubmodelElementCollection |value
|SubmodelElementList |value
|AnnotatedRelationshipElement |annotations
|Entity |statements
|===

*Example requests:*

GET /submodels/aHR0cHM6Ly9hZG1pbi1zaGVsbC5pby9zYW1wbGVTTQ/submodel/submodelElements/ sme1.sme2%5B0%5D.p1

Add a new Property to the Entity statements:

POST /submodels/aHR0cHM6Ly9hZG1pbi1zaGVsbC5pby9zYW1wbGVTTQ/submodel/submodelElements/ sme1.sme2%5B0%5D

====
Note 1: to avoid problems with IRI values in URLs, the identifiers shall be base64url-encoded before using them as parameters in the HTTP-APIs.
IdshortPaths are URL-encoded to also allow square brackets.
====

====
Note 2: in the example above, “aHR0cHM6Ly9hZG1pbi1zaGVsbC5pby9zYW1wbGVTTQ” is the base64url-encoding of “https://admin-shell.io/sampleSM”, “sme1.sme2%5B0%5D.p1” is the URL-encoding of “sme1.sme2[0].p1”, and “sme1.sme2%5B0%5D” is the URL-encoding of “sme1.sme2[0]”.
====

[#pagination]
== Pagination

Pagination is a commonly used pattern to break down potentially long result lists into smaller pieces for a better control of the network and computational load on both the server and the client side.
For instance, the OData protocol xref:bibliography.adoc#bib8[[8\]] provides guidelines for parameters and behavior on the client and server side.
In addition, the proposals of the RFC 8977 footnote:[see Chapter 2.4 of RFC 8977] present a best practice for web APIs.
In the scope of the AAS HTTP/REST API, the query parameter “cursor” controls, which part of a longer result set is returned.

The AAS client may define the maximum page size of the result list through the limit parameter.
The server is allowed to return less elements than requested.
If the limit parameter is not specified, the server may decide the number of elements to be returned.

Pagination is currently only defined for the HTTP/REST API.
Other APIs might introduce different patterns to control the response content.

Pagination is controlled by the client via the query parameters “cursor” and “limit”.
They can be combined with all other query parameters as defined in this document and listed in the following table:

.Parameters for Pagination
[%autowidth,width="100%",cols="15%,19%,8%,58%",options="header",]
|===
|Parameter |Values |Default |Explanation

e|Cursor |string |- a|
The position from which to resume a result listing.
The value may be base64url-encoded and contain additional information which helps the server to respond more efficiently.
However, the client must not expect any meaning and treat the cursor value as an arbitrary character sequence.

The server must interpret a missing cursor as if the client wants to retrieve the first part of the result set.

e|Limit |nonNegativeInteger |100 |The maximum size of the result list.
|===

{aasa001}

====
Note 1: this constraint prohibits that an empty cursor value is sent by the client, e.g. _…?cursor=""_.
====

====
Note 2: if the client sends a request without a cursor query parameter, the server must interpret it as if the client wants to retrieve the results from the very beginning.
A client may send the query parameter “limit" without any cursor.
In that case, the server must return at max the specified number of result items from the beginning.
====

Pagination assumes a deterministic sorting, i.e. the server implementation shall provide a deterministic
ordering of the result set. For instance, a server shall not return an element A before another element C and
in any later request return C before A. This applies in particular if any attribute of either A or C has been
changed between the two requests. However, in case a new element B was created (or deleted), the client
must be aware that e.g. B and then C are returned after A.

Nevertheless, the inherent order of the result shall stay the same. Implementations may maintain an
internal sorting attribute to ensure this behavior or implement it in any other appropriate manner. The server
is not obligated to inform the client about its ordering schema.

The client also needs to be aware, that changes may happen in pages which the client has already received,
that page results may change over time and that different clients may receive different page results.

The server informs the client about pagination attributes through the Result object in the request response.
In particular, the Result object contains the cursor value for the next page.
Additional optional server specific information may also be part of the result object, e.g. the overall number of result items.

[.table-with-appendix-table]
[cols="25%,40%,25%,10%"]
|===
h|Class Name 3+e|Result
h|Explanation 3+a|An object connecting the actual list of returned items with metadata information to, e.g. fetch the next part of the result set.
h|Inherits from 3+|--

h|Attribute h|Explanation h|Type h|Card.
e|result a|List of returned items. Any kind of Referables is possible, depending on the endpoint which has been requested. |Referable |0..*
e|paging_metadata a|Additional information for the client to, e.g. fetch the next part of the result set. |xref:PagingMetadata[PagingMetadata] |1
|===

[.table-with-appendix-table]
[cols="25%,40%,25%,10%"]
|===
h|Class Name 3+e|[[PagingMetadata]]PagingMetadata
h|Explanation 3+a| Additional information for the client to, e.g. fetch the next part of the result set.

====
Note: more attributes may be added to this class in future versions.
====

h|Inherits from 3+|--

h|Attribute h|Explanation h|Type h|Card.
e|cursor a|The cursor for the next part of the result set. No cursor attribute means that the end of the result set has been reached. |string |0..1
|===

== Payload

The payload is generated from the technology-neutral specification as described in Part 1 of the Asset Administration Shell Series for JSON xref:bibliography.adoc#bib1[[1\]].
// Previously pointing to Clause 11.4.2
The link:https://admin-shell-io.github.io/aas-specs-antora/IDTA-01001/v3.1/mappings/mappings.html#value-only-serialization-in-json[serialization of JSON values] is described in xref:bibliography.adoc#bib1[[1]].

Additional classes needed for payload of the HTTP/REST API specification can be found in xref:specification/interfaces-payload.adoc#metamodel-specification-details[Metamodel Specification Details].

[#modifier-constraints]
== Modifier Constraints

// Previously pointing to Clause 12.5
To use link:https://admin-shell-io.github.io/aas-specs-antora/IDTA-01001/v3.1/mappings/mappings.html#_format_metadata_metadata_serialization[metadata objects] as described in xref:bibliography.adoc#bib1[[1]]., modifiers are implemented as HTTP query parameters or path suffixes.
For example, a request for a specific submodel may look like: +
GET /submodel/$value?level=deep&extent=withBlobValue

The following constraints apply for the combination of modifiers:

* For Content=Value, the requested object shall always be serialized to an unnamed JSON Object or Array.
This means that the response object must not have a property with the object’s idShort at the root level.
* If Level=Core and Content=Value, only the requested object and the direct children without their value (empty value) will be returned in value serialization.
If a direct child is a SubmodelElementCollection, "<SubmodelElementCollection/idShort>": \{} will be returned.
If a direct child is a SubmodelElementList, "<SubmodelElementList/idShort>": [] will be returned.
* The combination of Content=Metadata and Extent=WithBLOBValue is not allowed.
* If parameter Content is set to "Metadata" then Level shall not be used.
A server shall respond with a ClientErrorBadRequest in this case.
* The combination of Level=Deep and Content=Reference is not allowed.
* Modifiers cannot be used for POST operations.

In addition, the modifiers can also be used for PUT operations.
They define how the request content is delivered and have the same semantics as in the related GET operation.
Only Content=Reference and Content=Path are not possible for PUT.

== Mapping of Operations

The following <<table-mapping-operations>> shows the mapping of the generic operations to the HTTP/REST API.

The black entries correspond to the corresponding generic operations.

[.blue]#The blue entries are operations which only exist in the HTTP/REST API.#

[[table-mapping-operations]]
.Mapping of the generic Interface Operations to HTTP API Operations
[%autowidth,width="100%",cols="31%,10%,23%,36%"]
|===
h|Operation Name h|HTTP Verb h|REST-Path h|Comment (e.g. optional query parameters)

4+h|Asset Administration Shell Interface
|GetAssetAdministrationShell |GET |/aas |content-suffix: $reference
|PutAssetAdministrationShell |PUT | |
|GetAllSubmodelReferences |GET |/aas/submodel-refs |Pagination
|PostSubmodelReference |POST |/aas/submodel-refs a| Location header of the response contains the value ‘<baseUrl>/aas/submodel-refs/\{submodelIdentifier}’
  
====
Note 1: submodelIdentifier is the base64url-encoded Submodel.id value.
  
Note 2: There is no API defined for a client to directly send a GET towards this URL of the Location header, however, the information is intended as an input for the DeleteSubmodelReference API Operation.
====

|DeleteSubmodelReference |DELETE |/aas/submodel-refs/\{submodelIdentifier} |use base64url-encoded identifier
|GetAssetInformation |GET |/aas/asset-information |
|PutAssetInformation |PUT |/aas/asset-information |
|GetThumbnail |GET |/aas/asset-information/thumbnail |
|PutThumbnail |PUT |/aas/asset-information/thumbnail |
|DeleteThumbnail |DELETE |/aas/asset-information/thumbnail |
| |* |/aas/submodels/\{submodel-identifier}/* |superpath as defined in service specification or profile

4+h|Submodel Interface
|GetSubmodel |GET |/submodel a|
?level=deep/core

path-suffix= $metadata/$value/$reference/$path or no suffix for normal

?extent=WithoutBLOBValue/WithBLOBValue

|PutSubmodel |PUT |/submodel |
|PatchSubmodel |PATCH |/submodel |path-suffix=$metadata/$value or no path for normal
|GetAllSubmodelElements |GET |/submodel/submodel-elements a|
?level=deep/core

path-suffix= $metadata/$value/$reference/$path or no suffix for nomal

?extent=WithoutBLOBValue/WithBLOBValue

Pagination

|GetSubmodelElementByPath |GET |/submodel/submodel-elements/\{idShortPath} a|
use separated idShortPath of this element

?level=deep/core

path-suffix= $metadata/$value/$reference/$path or no suffix for nomal +
?extent=WithoutBLOBValue/WithBLOBValue

*Note:* If a client uses a path-suffix for a SubmodelElement that has the associated Serialisation Modifier not defined (e.g. .../capabilityIdShort/$value), a server shall respond with a ClientErrorBadRequest (HTTP status code 400) and an appropriate error description in the response message.

URL-encoded IdShortPath

|GetFileByPath |GET |/submodel/submodel-elements/\{idShortPath}/attachment a|
use separated idShortPath of this element

URL-encoded IdShortPath

|PutFileByPath |PUT |/submodel/submodel-elements/\{idShortPath}/attachment a|
use separated idShortPath of this element

URL-encoded IdShortPath

|DeleteFileByPath |DELETE |/submodel/submodel-elements/\{idShortPath}/attachment a|
use separated idShortPath of this element

URL-encoded IdShortPath

|PostSubmodelElement |POST |/submodel/submodel-elements |SerializationModifiers are not used with POST
|PostSubmodelElementByPath |POST |/submodel/submodel-elements/\{idShortPath} a|
use separated idShortPath of the parent element

SerializationModifiers are not used with POST

|PutSubmodelElementByPath |PUT |/submodel/submodel-elements/\{idShortPath} a|
use separated idShortPath of this element

URL-encoded IdShortPath

|PatchSubmodelElementByPath |PATCH |/submodel/submodel-elements/\{idShortPath} a|
use separated idShortPath of this element

path-suffix=$metadata/$value or no suffix for normal

URL-encoded IdShortPath


====
Note: values remain unchanged with content=metadata
====


|PatchSubmodelElementValueByPath |PATCH |/submodel/submodel-elements/\{idShortPath}/$value a|
// Previously pointing to Clause 11.4.2
use separated idShortPath of this element; see xref:bibliography.adoc#bib1[[1]] for values

path-suffix=$value

URL-encoded IdShortPath

|DeleteSubmodelElementByPath |DELETE |/submodel/submodel-elements/\{idShortPath} a|
use separated idShortPath of this element

URL-encoded IdShortPath

|InvokeOperationSync |POST |/submodel/submodel-elements/\{idShortPath}/invoke a|
path-suffix=$value or no suffix for normal

URL-encoded IdShortPath

|InvokeOperationAsync |POST |/submodel/submodel-elements/\{idShortPath} +
/invoke-async a|
get operationHandle

path-suffix=$value or no suffix for normal

URL-encoded IdShortPath

|GetOperationAsyncResult |GET |/submodel/submodel-elements/\{idShortPath} +
/operation-results/ +
\{handleId} a|
handleId=operationHandle

path-suffix=$value or no suffix for normal

URL-encoded IdShortPath

4+h|Shell Repository Interface
|GetAllAssetAdministrationShells |GET |/shells a|
path-suffix=$reference or no suffix normal

Pagination

|GetAllAssetAdministrationShellsByAssetId |GET |/shells a|
base64url-encoded JSON-serialized key-value-pairs

?assetids=…

Pagination

|GetAllAssetAdministrationShellsByIdShort |GET |/shells a|
Pagination

?idShort=<idShort to query for>

|GetAssetAdministrationShellById |GET |/shells/\{aasIdentifier} a|
base64url-encoded identifier

path-suffix=$reference or no suffix normal

|PostAssetAdministrationShell |POST |/shells |
|PutAssetAdministrationShellById |PUT |/shells/\{aasIdentifier} |base64url-encoded identifier
|DeleteAssetAdministrationShellById |DELETE |/shells/\{aasIdentifier} |base64url-encoded identifier
|AasInterface |* |/shells/\{aasIdentifier}/* |superpath as defined in Service Specification or Profile
|QueryAssetAdministrationShells |POST |/query/shells a| Input query in the request body

4+h|Submodel Repository Interface
|GetAllSubmodels |GET |/submodels a|
path-suffix= $metadata/$value/$reference/$path or no suffix for normal

Pagination

|GetAllSubmodelsBySemanticId |GET |/submodels a|
?semanticId=<base64url-encoded value of the semanticId>

path-suffix= $metadata/$value/$reference/$path or no suffix for normal

{aasa002}

Pagination

|GetAllSubmodelsByIdShort |GET |/submodels a|
path-suffix= $metadata/$value/$reference/$path or no suffix for normal

Pagination

|GetSubmodelById |GET |/submodels/\{submodelIdentifier} a|
path-suffix=$metadata or no suffix for normal

base64url-encoded identifier

|PostSubmodel |POST |/submodels |
|PutSubmodelById |PUT |/submodels/\{submodelIdentifier} |base64url-encoded identifier
|PatchSubmodelById |PATCH |/submodels/\{submodelIdentifier} |path-suffix=$metadata/$value or no suffix for normal
|DeleteSubmodelById |DELETE |/submodels/\{submodelIdentifier} |base64url-encoded identifier
|SubmodelInterface |* |/submodels/\{submodelIdentifier}/* |superpath as defined in service specification or profile
|QuerySubmodels |POST |/query/submodels a| Input query in the request body

4+h|Concept Description Repository Interface
|GetAllConceptDescriptions |GET |/concept-descriptions |Pagination
|GetConceptDescriptionById |GET |/concept-descriptions/\{cdIdentifier} a|
base64url-encoded identifier

Pagination

|GetAllConceptDescriptionsByIdShort |GET |/concept-descriptions |Pagination
|GetAllConceptDescriptionsByIsCaseOf |GET |/concept-descriptions a|
base64url-encoded identifier

Pagination

|GetAllConceptDescriptionsByData
SpecificationReference |GET |/concept-descriptions a|
base64url-encoded identifier

Pagination

|PostConceptDescription |POST |/concept-descriptions/ |
|PutConceptDescriptionById |PUT |/concept-descriptions/\{cdIdentifier} |base64url-encoded identifier
|DeleteConceptDescriptionById |DELETE |/concept-descriptions/\{cdIdentifier} |base64url-encoded identifier
|QueryConceptDescriptions |POST |/query/concept-descriptions a| Input query in the request body

4+h|AASX File Server Interface
|GetAllAASXPackageIds |GET |/packages a|
base64url-encoded identifier

Pagination

|PostAASXPackage |POST |/packages |
|GetAASXByPackageId |GET |/packages/\{packageId} |base64url-encoded identifier
|PutAASXByPackageId |PUT |/packages/\{packageId} |base64url-encoded identifier
|DeleteAASXByPackageId |DELETE |/packages/\{packageId} |base64url-encoded identifier

4+h|Serialization Interface
|GenerateSerializationByIds |GET |/serialization |base64url-encoded identifier; AcceptHeader: application/aasx+xml or application/json oder application/xml

4+h|AAS Basic Discovery Interface
|GetAllAssetAdministrationShellIdsByAssetLink |GET |/lookup/shells a|
base64url-encoded JSON-serialized key-value-pairs

?assetids=…

Pagination

|GetAllAssetLinksById |GET |/lookup/shells/\{aasIdentifier} |base64url-encoded identifier
|PostAllAssetLinksById |POST |/lookup/shells/\{aasIdentifier} |base64url-encoded identifier
|DeleteAllAssetLinksById |DELETE |/lookup/shells/\{aasIdentifier} |base64url-encoded identifier

4+h|AAS Registry Interface
|GetAllAssetAdministrationShellDescriptors |GET |/shell-descriptors a|
Pagination

assetKind=Type\|Instance\|Role\|NotApplicable

assetType= base64url-encoded identifier

|GetAssetAdministrationShellDescriptorById |GET |/shell-descriptors/\{aasIdentifier} |base64url-encoded identifier
|PostAssetAdministrationShellDescriptorById |POST |/shell-descriptors/\{aasIdentifier} |base64url-encoded identifier
|PutAssetAdministrationShellDescriptorById |PUT |/shell-descriptors/\{aasIdentifier} |base64url-encoded identifier
|DeleteAssetAdministrationShellDescriptorById |DELETE |/shell-descriptors/\{aasIdentifier} |base64url-encoded identifier
|Submodel Registry Interface |* |/shell-descriptors/\{aasIdentifier}/submodelDescriptors/* |superpath as defined in Service Specification or Profile
|QueryAssetAdministrationShellDescriptors |POST |/query/shell-descriptors a| Input query in the request body
|CreateBulkAssetAdministrationShellDescriptors |POST |/bulk/shell-descriptors a| List of new Asset Administration Shell Descriptors in the request body
|PutBulkAssetAdministrationShellDescriptorsById |PUT |/bulk/shell-descriptors a| List of new versions of Asset Administration Shell Descriptors in the request body. Mapping to existing Asset Administration Shell Descriptors happens via the `id` attribute.
|DeleteBulkAssetAdministrationShellDescriptorsById |DELETE |/bulk/shell-descriptors a| List of Asset Administration Shell identifiers in the request body
|GetBulkAsyncStatus |GET |/bulk/status/{handleId} a| Server-side defined handle to retrieve the status of a previous bulk request.

====
Note: Same endpoint as for the Submodel Registry Interface bulk status. 
====

|GetBulkAsyncResult |GET |/bulk/status/{handleId} a| Server-side defined handle to retrieve the result of a previous bulk request.

====
Note: Same endpoint as for the Submodel Registry Interface bulk result. 
====

4+h|Submodel Registry Interface
|GetAllSubmodelDescriptors |GET |/submodel-descriptors |Pagination
|GetSubmodelDescriptorById |GET |/submodel-descriptors/\{submodelIdentifier} |base64url-encoded identifier
|PostSubmodelDescriptor |POST |/submodel-descriptors/\{submodelIdentifier} |base64url-encoded identifier
|PutSubmodelDescriptorById |PUT |/submodel-descriptors/\{submodelIdentifier} |base64url-encoded identifier
|DeleteSubmodelDescriptorById |DELETE |/submodel-descriptors/\{submodelIdentifier} |base64url-encoded identifier
|QuerySubmodelDescriptors |POST |/query/submodel-decriptors a| Input query in the request body
|CreateBulkSubmodelDescriptors |POST |/bulk/submodel-descriptors a| List of new Submodel Descriptors in the request body
|PutBulkSubmodelDescriptorsById |PUT |/bulk/submodel-descriptors a| List of new versions of Submodel Descriptors in the request body. Mapping to existing Submodel Descriptors happens via the `id` attribute.
|DeleteBulkSubmodelDescriptorsById |DELETE |/bulk/submodel-descriptors a| List of Submodel identifiers in the request body
|GetBulkAsyncStatus |GET |/bulk/status/{handleId} a| Server-side defined handle to retrieve the status of a previous bulk request.

====
Note: Same endpoint as for the Asset Administration Shell Registry Interface bulk status. 
====

|GetBulkAsyncResult |GET |/bulk/status/{handleId} a| Server-side defined handle to retrieve the result of a previous bulk request.

====
Note: Same endpoint as for the Asset Administration Shell Registry Interface bulk result. 
====

4+h|Descriptor Interface
|GetDescription |GET |/description |Provide additional information on interface endpoint; may also be used at a server endpoint to list all descriptions available on that server
|===

[#async-invocation-of-se-operation]
== Asynchronous Invocation of the SubmodelElement “Operation”

The invocation of the SubmodelElement “Operation” is the only call that can appear either synchronously or asynchronously in the current version of the specification.
The expected behavior is therefore explained in detail.

.Sequence for asynchronous invocations of the SubmodelElement 'Operation'
[[se-operation-invocation]]
[plantuml, se-operation-invocation, svg]
....
include::partial$diagrams/se-operation-invocation.puml[]
....

The client informs the server whether it is interested in a synchronous (asynchronous) call by targeting the /invoke (/invoke-async) endpoint.
In case of a synchronous interaction, the communication channel is kept open until the server has processed the request and responds with an OperationResult object, or a timeout or other kind of error occurs.

In the asynchronous pattern, the server immediately responds with an Accepted (status code: 202) message containing the link to an endpoint where the client can fetch status information about his request (see <<se-operation-invocation>>).
This status endpoint is also located at the same SubmodelElement “Operation”, followed by the path segments "/operation-status/\{handleId}”.

In case the request is incorrect and the server already recognizes it, the server responds directly with the according status code, e.g. 400.
If the server can only recognize the error during later processing and not at the time it receives the request, it responds with an Accepted (202) message at first.
Hence, a received Accepted message does not guarantee the client that its request is valid in every case.

If the server has not finished processing the request, the status endpoint responds with an BaseOperationResult object with the attribute “executionState” set to “Running”.
As soon as the processing is finished, the status endpoints deliver a Found (HTTP status code 302) response with the location of the result in the Location response header.
The result is, similar to the status information, provided at the same SubmodelElement “Operation”, followed by the path segments "/operation-result/\{handleId}”.

In case incorrect inputs have been provided by the client but the server was only able to recognize this during processing, or if the server perceived any other error during processing, the server must still provide the OperationResult object with status code 200 and set the attribute “executionState” to “Failed”.

====
Note: the invocation of the SubmodelElement “Operation” may also be conducted in the “ValueOnly” content.
In this case, the “/$value” path segment is added to the previously mentioned endpoints.
====

== Bulk Operations

This chapter provides a description of the Bulk APIs.
The Bulk APIs are designed to facilitate efficient and scalable operations on a large number of assets within the AAS.
This chapter outlines the key concepts, functionalities, and guidelines for implementing and utilizing the Bulk APIs.
Bulk operations are intended for the simultaneous manipulation of many objects.
Due to the size of bulk requests, it can be expected that the usual execution times takes significantly longer than for non-bulk requests.
To avoid frequent timeout errors, the AAS API only defines asynchronous bulk operations for HTTP.
The pattern for these operations follows the one introduced in <<async-invocation-of-se-operation>>.

.Sequence of a Bulk API Operation
[[sequence-of-bulk]]
[plantuml, sequence-of-bulk, svg]
....
include::partial$diagrams/sequence-of-bulk.puml[]
....

Bulk requests are solely sent to bulk endpoints, which must contain the “/bulk/” path segment.
A server may serve bulk endpoints together with non-bulk endpoints.
However, in case of available bulk operations, the server must also provide the so-called bulk status (/bulk/status/\{handle-id}) and bulk result (/bulk/result/\{handle-id}) endpoints.
A client executing a bulk request will retrieve the location of the status endpoint through the Location header of the response (see <<sequence-of-bulk>>).
As long as the request is processed, the status endpoint responds with “OK” with an optional information for the client when it shall ask again ("Retry-After").
As soon as the server was able to process the request, the status endpoint provides a redirect to the location of the result.
The result endpoint may either signal the client a success of the operation without any additional content, or an error together with a detailed error message in the body.
A server may remove information about the result of a bulk request after a certain amount of time.
A client requesting a bulk result may retrieve a ClientErrorResourceNotFound even though the bulk request has been processed if a certain amount of time has passed between the sending of the bulk request and the retrieval of the result.

====
Note: A server may remove a result object after a client has retrieved it at least once.
====

To ensure interoperability and consistency, the following guidelines should be adhered to when implementing and utilizing the Bulk APIs:

. Request Validation

Bulk requests should be validated against the AAS data model to ensure compliance with the defined asset structure and constraints.
Invalid or malformed requests should be rejected with appropriate error codes (see <<mapping-of-status-codes>>) and error messages.
In case the validation of the request as a whole would take too long, a server may accept the request at first hand but provide the – potential – validation result as the result object.
In particular, a client must not expect a correct request solely because the server has accepted the request at the first time.

[start=2]
. Atomicity

Bulk operations should be performed atomically, ensuring that either all operations within a bulk request are successfully executed, or none of them are.
If any individual operation fails, the entire bulk operation should be rolled back, and an appropriate error response should be generated.
A client must not expect that any part of the request has been persisted.

[start=3]
. Error Handling

Bulk responses should provide detailed information about the outcome of each individual operation within the bulk request.
In case of failures, error codes and error messages should be included to aid in troubleshooting and error resolution.
For each failed operation, at least one item in the message array of the result object shall be provided, linking unambiguously to the problematic incoming request item.
A client must not expect that the list of incorrect items is complete, as the server may terminate the execution already when the first error appears.

== Querying

Similar to bulk requests, queries are sent to the defined path segments "/query". Clients must use the POST to send queries to the server, with the serialized query in the request body. The result of a query, either the in the form of the result set or an error message, is returned in the http response. Asynchronous behavior by the AAS HTTP endpoints is not defined. 

The serialised query has to match the grammar as specified in Clause <<query-json-serialisation>>. If a server retrieves a mal-formed query, it must respond with a ClientErrorBadRequest message.

Servers may provide additional information about the perceived error, however, they are not obliged to do so.

AAS Servers expose their capability to support the AAS Querying by providing the according profile identifiers through their "/description" endpoint. If a server exposes a profile identifier in this manner, it must support all querying features that are contained in this profile. An AAS server might support more than one querying profile.

Even though the expressiveness of AAS queries have been limited to a basic amount, clients might still create a critical load at AAS servers, e.g., due to the amount of queries or certain time-expensive constructs. In such cases, servers can abort queries after a certain amount of time but have to inform the client accordingly.
// In addition, servers may restrict the amount of accepted requests at times of high loads. Servers do so by responding with a ComeBackLater message (TODO: introduce the "come back later" Status Code).

[[query-json-serialisation]]
=== Serialisation

The AAS Query Language for HTTP interactions is serialised in a JSON object. It has to be compliant to the following JSON Schema:

[source,json]
----
include::partial$query-json-schema.json[]
----

In case a syntax error is discovered by a receiver of an AAS query object, the query as a whole must be rejected with a `ClientErrorBadRequest`. A receiver may accept queries that extend the AAS Query Language, however, a Client must not expect any behavior or feature that are not included in the specific Query Language version that a server supports.


=== Endpoints

AAS queries are sent via POST requests, delivering the serialised query JSON in the request body, to the reserved query endpoint of an AAS service. This endpoint begins with the `/query` path segment, followed by a service-specific segment. For the Asset Administration Shell Repository, this is e.g. `/query/shells`. It is recommended that a server exposes its supported query profiles through the `/description` endpoint.



[#mapping-of-status-codes]
== Mapping of Status Codes

The following table shows the mapping of the generic status codes to HTTP status codes according to IETF RFC 7231 (see section 6.1: https://datatracker.ietf.org/doc/html/rfc7231#section-6)

.Status Code Mapping for HTTP
[%autowidth,width="100%",cols="29%,26%,18%,27%",options="header",]
|===
|[white]*xref:specification/interfaces-payload.adoc#StatusCode[Generic status code]* |*Meaning* |*HTTP status code* h|Explanation
|Success |Success |200 (OK) |Standard response for successful requests
|SuccessCreated |Successful creation of a new resource |201 (Created) |Successful request resulting in the creation of a new resource, e.g. SubmodelElement
|SuccessAccepted |The reception of the request was successful |202 (Accepted) |The server has accepted the request, but the result will be supplied later
|SuccessNoContent |Success with explicitly no content in the payload |204 (No Content) |Successful request with no content in return, e.g. used for updating existing resources
|ClientErrorBadRequest |Bad or malformed request |400 (Bad Request) |The server does not / cannot process the request due to a general client error, e.g. a malformed request
|ClientNotAuthorized |Wrong or missing authorization credentials |401 (Unauthorized) |The client missed or provided invalid credentials
|ClientForbidden |Authorization has been refused |403 (Forbidden) |The request content is basically valid and understood by the server, but the server refuses the action due to certain restrictions, e.g. profiles or roles
|ClientErrorResourceNotFound |Resource not found |404 (Not Found) |The requested resource was not found
|ClientMethodNotAllowed |Operation request is not allowed |405 (Method Not Allowed) |The server rejected the request for the requested resource, e.g. /invoke only for the operation submodel element
|ClientResourceConflict |Conflict-creating resource (resource already exists) |409 (Conflict) |A resource already exists; might occur if a Submodel or SubmodelElement with the same Identifier or ShortId is contained in a POST request.
|ServerInternalError |Unexpected error |500 (Internal Server Error) |General server-internal error due to an unexpected condition
|ServerNotImplemented |Not implemented |501 (Not Implemented) |The server does not support the functionality to fulfill the request
|ServerErrorBadGateway |Bad Gateway |502 (Bad Gateway) |The primarily addressed server that was acting as gateway or proxy received an invalid response from subsequent systems/servers
|===

== Additional Data Types for Payload for HTTP/REST

In addition to the data types used in the technology-neutral specification, the HTTP/REST API uses the data types as defined in this clause.

[#PackageDescription]
=== PackageDescription

[.table-with-appendix-table]
[cols="25%,40%,25%,10%"]
|===
h|Class Name 3+e|PackageDescription
h|Explanation 3+|
The package description consists of a system-wide unique packageId and its corresponding Asset Administration Shell identifiers.
The packageId is used to identify the AASX package at the AASX file server.
The package description is used to list the Asset Administration Shells in a given AASX package.
This class is not part of the metamodel.
h|Inherits from 3+|--

h|Attribute h|Explanation h|Type h|Card.
e|packageId a|File server specific package id |ShortIdType |1
e|aasId a|Asset Administration Shell unique identifier |Identifier |0..*
|===

