////
Copyright (c) 2023 Industrial Digital Twin Association

This work is licensed under a [Creative Commons Attribution 4.0 International License](
https://creativecommons.org/licenses/by/4.0/).

SPDX-License-Identifier: CC-BY-4.0

////

= General

== Services, Interfaces and Interface Operations

This document uses the Industrie 4.0 Service Model illustrated in

<<i40-service-model>> for a uniform understanding and naming. It basically distinguishes between associated concepts on several levels (from left to right):

* technology-neutral level: concepts that are independent from selected technologies;
* technology-specific level: concepts that are instantiated for a given technology and/or architectural style (e.g. HTTP/REST, OPC UA, MQTT);
* implementation level: concepts that are related to an implementation architecture that comprises one or more technologies (e. g. C#, C++, Java, Python);
* runtime level: concepts that are related to identifiable components in an operational Industry 4.0 system.

This document deals with the concepts of the technology-neutral and technology-specific level. However, to avoid terminological and conceptual misunderstandings, the whole Industrie 4.0 Service Model is provided here.

The technology-neutral level comprises the following concepts:

* *Service*: a service describes a demarcated scope of functionality (including its informational and non-functional aspects), which is offered by an entity or organization via https://www.plattform-i40.de/PI40/Redaktion/EN/Glossary/I/interface_glossary.html[interfaces].
* *Interface*: this is the most important concept as it is understood to be the unit of reusability across services and the unit of standardization when mapped to application programming interfaces (API) in the technology-specific level. One interface may be mapped to several APIs depending on the technology and architectural style used, e.g. HTTP/REST or OPC UA, whereby these API mappings also need to be standardized for the sake of interoperability.
* *Interface-Operation*: interface operations define interaction patterns via the specified interface.

The technology-specific level comprises the following concepts:

* *Service Specification*: specification of a service according to the notation, architectural style, and constraints of a selected technology. Among others, it comprises and refers to the list of APIs that forms this service specification. These may be I4.0-defined standard APIs but also other, proprietary APIs.


====
Note: such a technology-specific service specification may be but does not have to be derived from the “service” described in the technology-neutral form. It is up to the system architect and service engineer to tailor the technology-specific service according to the needs of the use cases.
====


* *API*: specification of the set of operations and events that forms an API in a selected technology. It is derived from the interface description on the technology-neutral level. Hence, if there are several selected technologies, one interface may be mapped to several APIs.
* *API-Operation*: specification of the operations (procedures) that may be called through an API. It is derived from the interface operation description on the technology-neutral level. When selecting technologies, one interface operation may be mapped to several API-operations; several interface operations may also be mapped to the same API-operation.

The implementation level comprises the following concepts:

* *Service-Implementation*: service realized in a selected implementation language following the specification in the Service Specification description on the technology-specific level.
* *API-Implementation*: set of operations realized in a selected implementation language following the specification in the API description on the technology-specific level.
* *API-Operation-Implementation*: concrete realization of an operation in a selected implementation language following the specification in the API-Operation description on the technology-specific level.

The runtime level comprises the following concepts:

* *Service-Instance*: instance of a Service-Implementation including its API-Instances for communication. Additionally, it has an identifier to be identifiable within a given context.

* *API-Instance*: instance of an API-Implementation which has an endpoint to get the information about this instance and the related operations.

* *API-Operation-Instance*: instance of an API-Operation-Implementation which has an endpoint to get invoked.

.Services, Interfaces & APIs and Operations
[[i40-service-model]]
image::i40-service-model.png[image3,width=608,height=361]

One important message from the Industrie 4.0 Service Model is that it is the level of the interface (mapped to technology-specific APIs) that

* provides the unit of reusability,
* is the foundation for interoperable services, and
* provides the reference unit for compliance statements.

Therefore, this document defines the interfaces and operations which are needed for interaction regarding the elements of the Asset Administration Shell metamodel starting with Clause 5.

== Design Principles

The operations of the interfaces follow a resource-oriented approach which is close to general REST principles but not as strict in every situation. The approach consists of the three main agreements:

* Stateless: the API is stateless. Each operation is independent. The server is always consistent after each operation.
* Resources (nouns): each resource is a clearly defined noun. This means that it has a specific name and its relation to other nouns is defined. The nouns and the relationships between them are taken from the list of referable objects of “Specification of the Asset Administration Shell Part 1” and their relationships. xref:specification/interfaces-payload.adoc#metamodel-specification-details[Metamodel Specification Details] gives an additional list of resources.
* Methods (verbs): a small set of standard REST methods (GET, POST, PUT, DELETE) is used to describe the semantic of the most common operations. There are only a few exceptions for situations where the standard methods do not fit (e.g. GETALL, SET, INVOKE).

The methods are:

* GET: a GET returns a single resource based on the resource identifier which is the identifier xref:bibliography.adoc#bib1[[1\]] for identifiables and the idShortPath for referables.
* GETALL: returns a list of resources based on optionally available parameters such as filters.
* QUERY: returns a list of resources based on filters expressed through the AAS Query Language.
* POST: creates a new resource. The identifier of the resource is part of the resource description. This is necessary because the id of identifiables is globally unique and should be the identifier for the object in every system. This implies that the creation of an identifiable is idempotent. There shall never be more than one identifiable with the same ID in one system. For example, trying to post the same AAS object twice will not create two AAS resources.
* PUT: replaces an existing resource.
* PATCH: updates an existing resource. The content to be replaced will be defined by the given SerializationModifiers, e.g. content=value provides the ValueOnly-serialization to update all values in the existing resource. The structure of the existing resource on the server and of the content given by the PATCH must be the same.



====
Note: values remain unchanged with content=metadata.
====


* DELETE: deletes a resource based on a given identifier.
* SET: sets the value of an object, e.g. the value of a Property.
* INVOKE: invokes an operation at a specified path.


====
Note: these methods are intended for the naming of interfaces as described in
<<i40-service-model>>. They shall not be interpreted as new protocol methods, e.g. on HTTP level.
====


Naming rules for operations:


The following rules shall apply for the operation names in Asset Administration Shell Interface, Submodel Interface, Shell Repository Interface, Submodel Repository Interface, Concept Description Repository Interface:

[listing]
....
<Interface Operation> ::= <Method Verb><Model Element Name>[<Modifier>]["By"<By-Qualifier>]

<Method Verb> ::= "Get" | "GetAll" | "Query" | "Put" | "PutBulk" | "Post" | "PostBulk" | "Patch" | "Delete" | "DeleteBulk" | "SetInvoke" | "InvokeAsync" | "SearchAll"

<Model Element Name> ::= "AssetAdministrationShell"["s"] | "AssetAdministrationShellDescriptor"["s"] | "SubmodelReference"["s"] | "AssetInformation" | "Submodel"["s"] | "SubmodelDescriptor"["s"] | "SubmodelElement"["s"] | "ConceptDescription"["s"]

<Modifier> ::= "Value" | "IdShortPath" | "Reference"

<By-Qualifier ::= |"Id" | "SemanticId" | "ParentPathAndSemanticId" | "Path" | "AssetId" | "IdShort" | "IsCaseOf" | "DataSpecificationReference"
....


[.underline]#Examples:#

_GetSubmodel_ has method verb “Get” and model element name “Submodel”.

_GetAllSubmodelElementsByPath_ has method verb “GetAll” and model element name “SubmodelElements” plus a by-qualifier “Path”.


== Semantic References for Operations

The operations of this document need unique identifiers to reach a common understanding and allow all involved parties to reference the same things. These identifiers need to be globally unique and understandable by the community and implementing systems. Furthermore, the identifiers need to support a versioning scheme for future updates and extensions of the metamodel. The identifiers defined in this document are reused in related resources, for instance REST API operations or in self-descriptions of implementing services.

Internationalized Resource Identifiers (IRIs), Uniform Resource Identifiers (URIs) xref:bibliography.adoc#bib5[[5\]] in particular, and the requirements of DIN SPEC 91406 xref:bibliography.adoc#bib6[[6\]], serve as the basic format. Further design decisions include ‘https’ as the URI scheme, and the controlled domain name ‘admin-shell.io’ as the chosen authority. Both decisions guarantee the interoperability of the identifiers and their durability, since URIs are generally well-known and proven, while the domain is controlled and served through the Plattform Industrie 4.0. All identifiers included in the ‘admin-shell.io’ domain are described in a lightweight catalogue in the form of markdown documents; they are continuously maintained and updated [https://github.com/admin-shell-io/id]. The catalogue itself is structured in several sub-namespaces specified by the first path parameter. All URIs of this document reflect entities of the core metamodel, which are contained in the sub-namespace identified with the ‘/aas/API’ path.

The described identifiers appear mainly in the semanticId field of every class and operation. They are required since the class name is not necessarily constant over time. The respective semanticIds, however, guarantee the unique and certain relation between a reference and the referenced class or operation. The URIs are constructed as follows (compare to Clause Semantic Identifiers for Metamodel and Data Specifications in Part 1 xref:bibliography.adoc#bib1[[1\]]).


====
Note 1: version information is explicitly included in each identifier.

Note 2: even though the usage of the ‘https’ scheme might indicate URLs, all identifiers are regarded as URI look ups; dereferencing them cannot be expected.
====


The following grammar is used to create valid identifiers:

[listing]
....

<Identifier> ::= <Namespace>"/aas/API/"<OperationName>"/"<Version>

<Namespace> ::= "https://admin-shell.io

<OperationName> ::= {<Character>}+

<Version> ::= {<Digit>}+"/"{<Digit>}+["/"{<Character>}+]

<Digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<Character> ::= an unreserved character permitted by DIN SPEC 91406

? ::= zero or one

+ ::= one or more
....

Examples for valid identifiers:

[example]
* \https://admin-shell.io/aas/API/GetSubmodel/1/23
* \https://admin-shell.io/aas/API/GetAllSubmodelElements/1/0/RC03
* \https://admin-shell.io/aas/API/GetAllSubmodelElements/3/0

Examples for invalid identifiers:

[example]
* \http://admin-shell.io/API/GetSubmodel/1/0 +
The scheme is different to ‘https’, and the ‘aas’ path segment is missing
* \https://admin-shell.io/aas/API/GetSubmodel +
Version information is missing
* \https://admin-shell.io/aas/API/GetSubmodel/1/0#0173-%20ABC#001 +
The URI includes DIN SPEC 91406-reserved (#) and impermissible (%) characters


== References and Keys

The concept of references is introduced in Part 1 of the series “Specification of the Asset Administration Shell” xref:bibliography.adoc#bib1[[1\]].

When defining interfaces, a distinction is made between relative references and absolute references.

Absolute references require a global unique id as starting point of the reference to be resolvable. In this case the type “Reference” is used.

Relative references do not start with a global unique id. Instead, it is assumed that the context is given and unique. In this case, the key list only contains keys with _Key/type_ that references a non-identifiable referable (e.g. a Property, a Range, a RelationshipElement, etc.).



== Relation of Interfaces

The following chapters define several interfaces, which work together as a system and support different deployment scenarios.

There are three major components of the overall system:

[arabic]
. Repositories store the data of Asset Administration Shells, Submodels, and Concept Descriptions,
. Registries are “directories” which store AAS-IDs and Submodel-IDs together with the related endpoints (typically a URL-path into a repository or to a single AAS/Submodel),
. discovery (servers) supports a fast search and only store copies of essential information, i.e. key value pairs to find IDs by other IDs.

<<asset-related-info-retrieval>> shows a typical sequence. Discovery finds the AAS-ID for a given Asset-ID. A Registry provides the endpoint for a given AAS-ID. Such an endpoint for an AAS and the related Submodel-IDs make the submodels with their submodelElements accessible.

.Retrieval of Asset-related Information by AAS and Submodels
[[asset-related-info-retrieval]]
image::asset-related-info-retrieval.jpeg[width=642,height=610]

The Asset Administration Shell model is an asset-oriented model.

An Asset-ID may be retrieved e.g. by a QRCODE on the asset, by an RFID for the asset, from the firmware of the asset or from an asset database. IEC 61406 (formerly DIN SPEC 91406) defines the format of such Asset-IDs.

The “Administration Shell Basic Discovery Interface” may be used with an Asset-ID to get the related AAS-IDs (“GetAllAssetAdministrationShellIdsByAssetLink”).

The “Asset Administration Shell Registry Interface” may be used with an AAS-ID to retrieve the related descriptor for an AAS (“GetAssetAdministrationShellDescriptorById”). The retrieved AAS Descriptor includes the endpoint for the “Asset Administration Shell Interface”.

The “Asset Administration Shell Interface” makes the information about the AAS itself and the references to the related submodels available.

The related submodels of an AAS are retrieved by “GetAllSubmodelReferences”. Such a reference includes the SM-ID of a related submodel.

Similarly to the AAS above, the “Submodel Registry Interface” may be used to retrieve the related descriptor for a submodel (“GetSubmodelDescriptorById”) with a specific SM-ID. The retrieved Submodel Descriptor includes the endpoint for the “Submodel Interface”.

The “Submodel Interface” makes the information about the submodel itself and all its included submodel elements available.

Asset Administration Shells and submodels may be deployed on different endpoints in different ways.

One example is the deployment of an AAS on a device. In this case, the AAS might be fixed and might not be changed or deleted. In a cloud scenario, a single AAS may also be deployed as a single container (e.g. docker container).

Another example is the deployment of many Asset Administration Shells in an AAS Repository. In this case, the “Asset Administration Shell Repository Interface” may allow to create and manage multiple AAS in the repository.

The separate interfaces of the HTTP/REST API allow many ways to support different deployments.

For an AAS repository, the combination [.gray]#“Asset Administration Shell Repository Interface”#, [.red]#“Asset Administration Shell Interface”#, [.blue]#“Submodel Interface”#, “Serialization Interface”, and “Self-Description Interface” is proposed.

This will result in the following HTTP/REST paths as described in a combined OpenAPI file (https://app.swaggerhub.com/apis/Plattform_i40/AssetAdministrationShellRepositoryServiceSpecification/V3.1_SSP-001)[For easier reading only the standard paths are shown in the following: $metadata, $value, $reference and $path parameter paths are additionally contained in the OpenAPI file.]:

[.gray]#/shells# +
[.gray]#/shells/\{aas-identifier}# +
[.gray]#/shells/\{aas-identifier}#[.red]##/asset-information## +
[.gray]#/shells/\{aas-identifier}#[.red]##/asset-information/thumbnail## +
[.gray]#/shells/\{aas-identifier}#[.red]##/submodel-refs## +
[.gray]#/shells/\{aas-identifier}#[.red]##/submodel-refs/\{submodel-identifier}## +
[.gray]#/shells/\{aas-identifier}#[.red]##/submodels/\{submodel-identifier}## +
[.gray]#/shells/\{aas-identifier}#[.red]##/submodels/\{submodel-identifier}##[.blue]#/submodel-elements# +
[.gray]#/shells/\{aas-identifier}#[.red]##/submodels/\{submodel-identifier}##[.blue]#/submodel-elements/\{idShortPath}# +
[.gray]#/shells/\{aas-identifier}#[.red]##/submodels/\{submodel-identifier}##[.blue]#/submodel-elements/\{idShortPath}/attachment# +
[.gray]#/shells/\{aas-identifier}#[.red]##/submodels/\{submodel-identifier}##[.blue]#/submodel-elements/\{idShortPath}/invoke# +
[.gray]#/shells/\{aas-identifier}#[.red]##/submodels/\{submodel-identifier}##[.blue]#/submodel-elements/\{idShortPath}/invoke-async# +
[.gray]#/shells/\{aas-identifier}#[.red]##/submodels/\{submodel-identifier}##[.blue]#/submodel-elements/\{idShortPath}/operation-status/\{handleId}# +
[.gray]#/shells/\{aas-identifier}#[.red]##/submodels/\{submodel-identifier}##[.blue]#/submodel-elements/\{idShortPath}/operation-results/\{handleId}# +
/serialization +
/description

If the repository also supports AASX Packages, it shall be extended by additionally supporting a “AASX File Server” Profile [Related OpenAPI file: https://app.swaggerhub.com/apis/Plattform_i40/AasxFileServerServiceSpecification/V3.1_SSP-001].

The example of a device or container containing one AAS with its related submodels will result in the following HTTP/REST paths as described in the related OpenAPI file (https://app.swaggerhub.com/apis/Plattform_i40/AssetAdministrationShellServiceSpecification/V3.1_SSP-001)^2^:

[.red]#/aas# +
[.red]#/aas/asset-information# +
[.red]#/aas/asset-information/thumbnail# +
[.red]#/aas/submodel-refs# +
[.red]#/aas/submodel-refs/\{submodel-identifier}# +
[.red]#/aas/submodels/\{submodel-identifier}# +
[.red]#/aas/submodels/\{submodel-identifier}#[.blue]##/submodel-elements## +
[.red]#/aas/submodels/\{submodel-identifier}#[.blue]##/submodel-elements/\{idShortPath}## +
[.red]#/aas/submodels/\{submodel-identifier}#[.blue]##/submodel-elements/\{idShortPath}/attachment## +
[.red]#/aas/submodels/\{submodel-identifier}#[.blue]##/submodel-elements/\{idShortPath}/invoke## +
[.red]#/aas/submodels/\{submodel-identifier}#[.blue]##/submodel-elements/\{idShortPath}/invoke-async## +
[.red]#/aas/submodels/\{submodel-identifier}#[.blue]##/submodel-elements/\{idShortPath}/operation-status/\{handleId}## +
[.red]#/aas/submodels/\{submodel-identifier}#[.blue]##/submodel-elements/\{idShortPath}/operation-results/\{handleId}## +
/serialization +
/description


====
Note: identifiers are base64url-encoded in the API, i.e. \{aas-identifier} and [.green]#\{submodel-identifier}#. [.blue]#The \{idShortPath} is URL-encoded in the API#.
====


== Query Language

Many use cases of the Asset Administration Shell require the involvement of a high number of Asset Administration Shells at the same time. Executing the business logic on all potentially involved Asset Administration Shells solely by the client application requires a huge amount of transferred data objects and bandwidth. It is therefore necessary to move parts of the filter and selection logic to the AAS hosting systems. The AAS Query Language enables AAS clients to describe and handover their interests and AAS servers to only respond with the needed data objects.

The Asset Administration Shell propagates a Query Language inspired by the so-called Resource Query Language (RQL [_add reference_]). This language follows a simplified grammar and expressiveness compared with RQL and other languages with a similar scope, e.g. SPARQL [add reference], GQL [add reference], or JsonPath [add reference]. The same language shall be used independent of the communication protocol, therefore, it is not limited to the HTTP API of the AAS.

// TODO: Add correct overview picture
.Main elements of the AAS Query Language
image::../images/plantuml/query-language-overview.png[image24,width=642,height=367]


=== Limitations

The AAS Query Language is not intended as feature-comparable to existing query languages like SPARQL or GQL. In case the expressiveness of such technologies is needed, a software vendor might additionally provide such APIs. However, in order to keep the additional overhead for AAS Query Language implementers as small as possible, the following limitations apply:

1. Only Identifiables are queryable: It is only possible to formulate filters for Asset Administration Shells, Submodels, and their according Descriptors, as well as ConceptDescription. In addition, also their identifiers (values of the "id" attributes) can be queried.

1. Only Repository and Registry Services have query functionalities: Querys on Asset Administration Shell Services or Submodel Services are not defined.

1. It is only possible to compare a field to an atomic value. It is not possible to compare two fields with each other. (TODO: verify with TF)

1. Only attributes defined by the AAS Metamodel (TODO: insert reference) can be used to in filters: Usage of custom attributes that are not defined by the AAS specifications may be rejected by the receiving party.


=== Grammar

The AAS Query Language is defined in the context-free Backus-Naur form (BNF). See Appendix (TODO: insert reference) for more details on BNF. Same as for AAS Interfaces and Operations, the detailed serialisation and interaction pattern is defined by the different technology mappings. In particular, the AAS HTTP API represents AAS Queries as JSON objects (see Clause (TODO: insert reference)). Other mappings may require different serialisations, however, all have to follow the general structure of queries defined in the following grammar.


// Updated grammar 2024-10-11 (from aorzelski) + additional extensions 2024-11-02 (from sebbader-sap)
This is the combined grammar for the AAS Query Language and the AAS Access Rules defined by the AAS Security specification (TOOD: add reference).
// (check by https://bnfplayground.pauliankline.com/)
// (see a running parser at https://grammar.aas-voyager.com/ )

// TODO: explain why only 'id' is available for sorting

include::./grammar.adoc

// examples for grammar as of 2024-11-02:
// sm.$semanticId.$type eq "abc"
// sme.someIdShort.someOtherIdShort.$semanticId.$type eq "abc"
// sme.someIdShort.someOtherIdShort[3].$semanticId.$type eq "abc"
// sm.$idShort eq "example"
// contains(sm.$displayName.$text, "test")
// contains(sm.$description.$text, "test")
// sm.$idShort eq "example" and contains(sm.$description.$text, "test")
// not(hex("12") gt 16#0ACD)  or 12 eq num("12")
// not(hex("12") gt 16#0ACD) or (hex(sm.$idShort) ne 16#ABC and sme.$value gt 12) or 12 eq num("12")
// time(GLOBAL(LOCALNOW)) ge 09:00 and time(GLOBAL(LOCALNOW)) le 17:00
// select id where sm.$idShort eq "someIdShort"


// Examples for updated grammar:
// sm.idShort eq "example"
// contains(sm.description, "test")
// sm.idShort eq "example" and contains(sm.description, "test")
// not(hex("12") gt 16#0ACD) or (hex(sm.idShort) ne 16#ABC and sme.value gt 12) or 12 eq num("12")
// time(GLOBAL(LOCALNOW)) ge 09:00 and time(GLOBAL(LOCALNOW)) le 17:00

// Examples for initial grammar (todo: delete before publication):
// select id where idShort = "someIdShort"


=== Comparison Operators

The following comparison operators are part of the query language. The result of a comparison shall always be (a) of type xs:boolean or (b) a comparison error, e.g., due to non-matching inputs.

Comparisons are overloaded, which means that the same comparison can deal with several input types. For instance, `eq`  can be used both for values of type xs:string and xs:int.

// TODO decide on alternative:
// Comparisons are generally not overloaded (TODO: Reference to https://www.w3.org/TR/xpath-functions-30/#func-overloading). This means that one single comparison operator shall only be used for the defined input type and result in an error otherwise. For instance, `eq` / `=` requires two input parameters of type xs:string. If the input parameters are of type xs:int, `numeric_equals` shall be used. Note that the functions for numeric comparisons, like `numeric_equals`, can be used for all numeric types (xs:int, xs:float, xs:double). Therefore, `numeric_equals` can compare a value of type xs:int with a value of type xs:double, according to the defined comparison rules.



[.table-with-appendix-table]
[width=100%, cols="10%,40%,50%"]
|===
h| Operator h| Description h| Definition
| eq | Compares two values if they are identical. | Operator 'A eq B' in https://www.w3.org/TR/xpath-30/#mapping 
| ne | Compares two values if they are not identical. | Operator 'A eq B' in https://www.w3.org/TR/xpath-30/#mapping 
| gt | Checks whether one parameter is greater than another. | Operator 'A gt B' in https://www.w3.org/TR/xpath-30/#mapping 
| lt | Checks whether one parameter is lower than another. | Operator 'A lt B' in https://www.w3.org/TR/xpath-30/#mapping 
| ge | Checks whether one parameter is greater or equal than another. | Operator 'A ge B' in https://www.w3.org/TR/xpath-30/#mapping 
| le | Checks whether one parameter is lower or equal than another. | Operator 'A ne B' in https://www.w3.org/TR/xpath-30/#mapping 
| starts-with | Compares two string expressions whether the first parameter appears character-equal at the beginning of the second. | Defined as fn:starts-with in https://www.w3.org/TR/xpath-functions-30/#func-starts-with
| ends-with | Compares two string expressions whether the first parameter appears character-equal at the end of the second. | Defined as fn:ends-with in https://www.w3.org/TR/xpath-functions-30/#func-ends-with
| regex | Evaluates a regex expression in the first parameter against the string content of the second. | Defined as fn:contains in https://www.w3.org/TR/xpath-functions-30/#func-contains
// TODO: do we need an 'exists'? | exists | Checks if the argument is a non-empty sequence. | Defined as fn:exists in https://www.w3.org/TR/xpath-functions-30/#func-exists
|===


=== Logical Expressions

Logical expressions allow the combination of two or more single comparisons through AND or OR relations, and to negate the result of an expression. Furthermore, logical expressions can also used to combine other logical expressions.

[.table-with-appendix-table]
[width=100%, cols="10%,40%,50%"]
|===
h| Logical Operator h| Description h| Definition
| and | Connects two expressions through a logical AND. | Defined by https://www.w3.org/TR/xpath-30/#doc-xpath30-AndExpr 
| or | Connects two expressions through a logical OR. |  Defined by https://www.w3.org/TR/xpath-30/#doc-xpath30-OrExpr 
| not | Negates an expression. | The "not" operator inverts the truth value of its operand. If the operand is true, the result is false, and if the operand is false, the result is true. not( true ) --> false // TODO: Find a proper definition.
|===




=== Casting Operators

[.table-with-appendix-table]
[width=100%, cols="10%,40%,50%"]
|===
h| Casting Operator h| Description h| Definition
| str(<value>) | Casts the `value` to string. | Defined by https://www.w3.org/TR/xpath-functions-30/#func-string
| num(<value>) | Casts the `value` to string. |  Defined by https://www.w3.org/TR/xpath-functions-30/#func-number __TODO:__ This implies that only double comparisons are possible...
| dateTime(<value>) | Casts the `value` to xs:dateTime. | Defined by https://www.w3.org/TR/xpath-functions-30/#func-dateTime
| bool(<value>) | Casts the `value` to xs:boolean. | Defined by https://www.w3.org/TR/xpath-functions-30/#func-boolean
|===

// TODO: There are no castings to time or binary in XPath. This might have valid reasons...


=== Referring to Elements in Lists and Arrays

The AAS Metamodel defines several objects with lists as child elements, e.g., `SubmodelElementList/value`, `AssetInformation/specificAssetIds`, or `Reference/keys`. The AAS Query Language contains two different patterns to refer to elements inside these lists:

==== Specific Index Notation

In case the position inside the list is known, the query can directly leverage the index number inside square brackets.

....
fieldIdentifier[<index>]
....

For a the first element of a SubmodelElementList, this notation may lead to a following declaration:

....
sme.someIdShort.smlIdShort[0]
....

For the first key of a SemanticId reference, this notation may lead to a following declaration:

....
<somePath>.$semanticId.keys[0]
....


==== Any Element Notation

In case the position in the list is not known, the index inside the square brackets can be skipped. This means that at least one element has to fulfill the comparison to make the expression evaluate to `true`. 

....
fieldIdentifier[]
....

To refer to any element inside a SubmodelElementList, this notation may lead to a following declaration:

....
sme.someIdShort.smlIdShort[]
....

For any key of a SemanticId reference, this notation may lead to a following declaration:

....
<somePath>.$semanticId.keys[]
....


==== Example

The following example is used to illustrate the evaluation of the query language. Note that the attributes "description" and "displayName" are left blank intentionally.

```
{
    "modelType": "AssetAdministrationShell",
    "id": "https://example.com/asset-administration-shell-1",
    "assetInformation": {
        "assetKind": "Instance",
        "globalAssetId": "urn:asset-administration-shell-1",
        "specificAssetIds": [
            {
                "name": "supplierId",
                "value": "aas-1"
            },
            {
                "name": "customerId",
                "value": "aas-2"
            }
        ],
    },
    "submodels": [
        {
            "type": "ModelReference",
            "keys": [
                {
                    "type": "Submodel",
                    "value": "https://example.com/submodel-1"
                }
            ]
        },
        {
            "type": "ModelReference",
            "keys": [
                {
                    "type": "Submodel",
                    "value": "https://example.com/submodel-2"
                }
            ]
        }
    ],
}
```

// TODO: Table is not correct anymore, e.g., "displayName" -> "$displayName.$text"
[.table-with-appendix-table]
[width=100%, cols="45%,10%,45%"]
|===
h| Comparison h| Result h| Comment
| "displayName" eq "description" | true | Empty nodelists
| "displayName" le  "description" | true | `eq` implies `le`
| "displayName" eq 'value' | false | Empty nodelist in the example object, which always evaluates to `false` for `eq`
| ne( "displayName", "description" ) | false | Empty nodelists
| ne( "displayName", 'value' ) | true | Empty nodelist
| le( 1, 2 ) | true | Numeric comparison
| gt( 1, 2 ) | false | Numeric comparison
| eq( 13, '13' ) | false | Type mismatch
| le( 'a', 'b' ) | true | String comparison
| gt( '1', '2' ) | false | String comparison
| eq( "assetInformation", "submodels" ) | false | Type mismatch (object vs. list)
| ne( "assetInformation", "submodels" ) | true | Type mismatch
| eq( "assetInformation", "assetInformation" ) | true | Object comparison
| ne( "assetInformation", "assetInformation" ) | false | Object comparison
| eq( "submodels", "submodels" ) | true | Array comparison
| ne( "submodels", "submodels" ) | false | Array comparison
| eq( "assetInformation", 17 ) | false | Type mismatch
| ne( "assetInformation", 17 ) | true | Type mismatch
| le( "assetInformation", "submodels" ) | false | Objects and arrays do not offer `lt` comparison
| lt( "assetInformation", "submodels" ) | false | Objects and arrays do not offer `lt` comparison
| lt( "assetInformation", "assetInformation" ) | true | `eq` / `=` implies `le` also for objects
| le( "submodels", "submodels" ) | true | `eq` / `=` implies `le` also for lists
| le( 1, "submodels" ) | false | Lists do not offer `lt`/`gt` comparison
| ge( 1, "submodels" ) | false | Lists do not offer `lt`/`gt` comparison
| gt( 1, "submodels" ) | false | Lists do not offer `lt`/`gt` comparison
| lt( 1, "submodels" ) | false | Lists do not offer `lt`/`gt` comparison
| le( true, true ) | true | `eq` / `=` implies `le`
| gt( true, true ) | false | Booleans do not offer `lt`/`gt` comparison
| like( "id", "https://example.com/asset-administration-shell-*" ) | true | Like comparison matches entities based on the specified attribute's value,
including case sensitivity — either upper or lower case. Typically, the value includes wildcards such as '?' or '*', allowing for more flexible matching.
|===


=== Nested Comparisons (todo: find better name for this effect. Proposals: 1. Hierarchical Comparisons, 2. Structured Comparisons, 3. Sequential Comparisons)

// TODO: Introduce "elemMatch" in grammar or only in the JSON Schema?

[.table-with-appendix-table]
[width=100%, cols="50%,10%,30%"]
|===
h| Comparison h| Result h| Comment
| and (

    eq( "assetInformation.specificAssetIds.name", 'supplierId' ) ,

    eq( "assetInformation.specificAssetIds.value", 'aas-1' )

 )
| [ { "modelType": "AssetAdministrationShell", ... } ] | The values for 'supplierId' and 'aas-2' exist in the same SpecificAssetId object.
| and (

    eq( "assetInformation.specificAssetIds.name", 'supplierId' ) ,

    eq( "assetInformation.specificAssetIds.value", 'aas-2' )

 )
| [ { "modelType": "AssetAdministrationShell", ... } ] | The values for 'supplierId' and 'aas-2' exist in the example AAS, even though in different SpecificAssetId objects.
|
  like( "assetInformation.specificAssetIds.value", 'aas-*' )
| [ { "modelType": "AssetAdministrationShell", ... } ] | The values for 'aas-1' and 'aas-2' exist in the example AAS, even though in different SpecificAssetId objects.
|
TODO: This doesn't align well with the existing RQL definitions and would be hard challenge to parse it. We need something different which is more aligned with RQL

"assetInformation.specificAssetIds"(

and (

eq( "name", 'supplierId' ) , eq( "value", 'aas-2' )

)
| empty list | The values for 'supplierId' and 'aas-2' in the same SpecificAssetId object.
|===


=== Sorting and Pagination

==== Pagination
To manage the pagination of the retrieved data, incorporate the limit operator within the options configuration.

[source,javascript]
----
option=limit(start,count)
----

[.table-with-appendix-table]
[width=100%, cols="25%,75%"]
|===
h| Operator h| Description
| limit | To control the pagination of the retrieved data, use the limit operator
| start | specifies where to start fetching data, also known as offset
| count | indicates how many results to fetch per page // TODO not matching the grammar anymore
|===

Example
[source,javascript]
----
option=limit(10,5)
----

==== Sorting

To organize the retrieved data in a specific order, incorporate the sort operator within the options configuration.

[source,javascript]
----
option=sort([ASC|DSC]attributeN)
----

The sort operator organizes data based on the specified attributes. It begins with the first attribute and continues sequentially to subsequent attributes.
Attribute names should be separated by commas. For each attribute, you can designate the sorting direction - ascending or descending.

[.table-with-appendix-table]
[width=100%, cols="25%,75%"]
|===
h| Operator h| Description
| sort | To sort the retrieved data, use the sort operator as part of the option operator.
| ASC | For descending sort order.
| DSC | For ascending sort order.

|===

Example
[source,javascript]
----
option=sort(+assetInformation, -assetInformation.globalAssetId)
----
// TODO not matching the grammar anymore

// todo: Explain LIMIT, OFFSET/SKIP, SORT
